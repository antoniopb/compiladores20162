/**
 * generated by Xtext 2.11.0.RC2
 */
package org.xtext.ufcg.compiladores.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.xtext.ufcg.compiladores.pascal.PascalPackage;
import org.xtext.ufcg.compiladores.pascal.abstraction_declaration;
import org.xtext.ufcg.compiladores.pascal.abstraction_heading;
import org.xtext.ufcg.compiladores.pascal.any_number;
import org.xtext.ufcg.compiladores.pascal.array_type;
import org.xtext.ufcg.compiladores.pascal.assignment_statement;
import org.xtext.ufcg.compiladores.pascal.block;
import org.xtext.ufcg.compiladores.pascal.conditional_statement;
import org.xtext.ufcg.compiladores.pascal.conformant_array_schema;
import org.xtext.ufcg.compiladores.pascal.constant;
import org.xtext.ufcg.compiladores.pascal.constant_definition;
import org.xtext.ufcg.compiladores.pascal.constant_definition_part;
import org.xtext.ufcg.compiladores.pascal.expression;
import org.xtext.ufcg.compiladores.pascal.expression_list;
import org.xtext.ufcg.compiladores.pascal.factor;
import org.xtext.ufcg.compiladores.pascal.file_type;
import org.xtext.ufcg.compiladores.pascal.formal_parameter_list;
import org.xtext.ufcg.compiladores.pascal.formal_parameter_section;
import org.xtext.ufcg.compiladores.pascal.function_designator;
import org.xtext.ufcg.compiladores.pascal.if_statement;
import org.xtext.ufcg.compiladores.pascal.number;
import org.xtext.ufcg.compiladores.pascal.packed_conformant_array_schema;
import org.xtext.ufcg.compiladores.pascal.parameter_type;
import org.xtext.ufcg.compiladores.pascal.pointer_type;
import org.xtext.ufcg.compiladores.pascal.procedure_and_function_declaration_part;
import org.xtext.ufcg.compiladores.pascal.program;
import org.xtext.ufcg.compiladores.pascal.record_type;
import org.xtext.ufcg.compiladores.pascal.set;
import org.xtext.ufcg.compiladores.pascal.set_type;
import org.xtext.ufcg.compiladores.pascal.simple_expression;
import org.xtext.ufcg.compiladores.pascal.simple_statement;
import org.xtext.ufcg.compiladores.pascal.simple_type;
import org.xtext.ufcg.compiladores.pascal.statement;
import org.xtext.ufcg.compiladores.pascal.statement_sequence;
import org.xtext.ufcg.compiladores.pascal.structured_statement;
import org.xtext.ufcg.compiladores.pascal.structured_type;
import org.xtext.ufcg.compiladores.pascal.term;
import org.xtext.ufcg.compiladores.pascal.type;
import org.xtext.ufcg.compiladores.pascal.type_definition;
import org.xtext.ufcg.compiladores.pascal.type_definition_part;
import org.xtext.ufcg.compiladores.pascal.unpacked_conformant_array_schema;
import org.xtext.ufcg.compiladores.pascal.unpacked_structured_type;
import org.xtext.ufcg.compiladores.pascal.value_parameter_section;
import org.xtext.ufcg.compiladores.pascal.variable;
import org.xtext.ufcg.compiladores.pascal.variable_declaration_part;
import org.xtext.ufcg.compiladores.pascal.variable_parameter_section;
import org.xtext.ufcg.compiladores.pascal.variable_section;
import org.xtext.ufcg.compiladores.validation.APIProvider;
import org.xtext.ufcg.compiladores.validation.AbstractPascalValidator;
import org.xtext.ufcg.compiladores.validation.AdaptativeHashMap;
import org.xtext.ufcg.compiladores.validation.AdaptativeTreeSet;
import org.xtext.ufcg.compiladores.validation.ComposedType;
import org.xtext.ufcg.compiladores.validation.ComposedTypeKind;
import org.xtext.ufcg.compiladores.validation.Element;
import org.xtext.ufcg.compiladores.validation.ElementType;
import org.xtext.ufcg.compiladores.validation.ErrorType;
import org.xtext.ufcg.compiladores.validation.Function;
import org.xtext.ufcg.compiladores.validation.Procedure;
import org.xtext.ufcg.compiladores.validation.Type;
import org.xtext.ufcg.compiladores.validation.TypeInferer;
import org.xtext.ufcg.compiladores.validation.Variable;

@SuppressWarnings("all")
public class PascalValidator extends AbstractPascalValidator {
  private final String NIL = "nil";
  
  private final String RECORD = "record";
  
  private final String CHAR = "char";
  
  private final String BOOLEAN = "boolean";
  
  private final String INTEGER = "integer";
  
  private final String REAL = "real";
  
  private final String POINTER = "^";
  
  private final String ARRAY = "array of ";
  
  private final String UNDEFINED_TYPE_MESSAGE = "Tipo indefino";
  
  private final String CANNOT_CONVERT_MESSAGE = "Não é possivel converter ";
  
  private final String BOOL_ONLY = "Somente tipos booleanos são aceitos em condicionais.";
  
  private final String VAR_NOT_DECL = "Variavel não foi declarada.";
  
  private final String CONST_NOT_DECL = "Constante não pode ser redeclarada.";
  
  private final String CONST_ONLY = "Só são aceita constantes.";
  
  private final String NUM_ONLY = "Somente tipos numericos são aceitos.";
  
  private final String NAN = "A variavel não é um numerica.";
  
  private final String TO_BOOL = " para o tipo booleano.";
  
  private final String TO_NUM = " para um numerico.";
  
  private final String INVALID_OP = "Operador invalido para o tipo booleano.";
  
  private final String VAR_NOT_INIT = "Variavel não foi inicializada.";
  
  private final String RECEIVED = " foram recebidos ";
  
  private final String CANNOT_REDECLARE = " não pode ser redeclarada.";
  
  private final String FUNC_NOT_DECL = "Função não foi declarada.";
  
  private final String ID_FUNC_RETURN = "Identificador reservado para retorno de função.";
  
  private final String ID_IN_USE = "Identificador já está sendo usado por ";
  
  private final String CONST_CNOT_ASSIGN = "Constants cannot be assigned.";
  
  private final String ARG_WRONG_NUM = "Número incorreto de argumentos, esperava-se ";
  
  private final String ARGS = " argumentos.";
  
  private final String INCOMPATIBLE_TYPES = "Tipos de argumentos incompativeis, esperava-se ";
  
  private final String FUNC_ONLY = "Chamadas de Procedures não são permitidas em expressões.";
  
  private final String TO_MESSAGE = " para ";
  
  public final static Map<String, Map<String, Object>> tabela_de_simbolos = new HashMap<String, Map<String, Object>>();
  
  private final Map<block, Set<Variable>> variaveis = new AdaptativeHashMap<block, Variable>();
  
  private final Map<block, Set<Procedure>> procedimentos = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
  
  private final Map<EObject, Set<org.xtext.ufcg.compiladores.validation.Error>> mapaDeErros = new AdaptativeHashMap<EObject, org.xtext.ufcg.compiladores.validation.Error>();
  
  private final Map<block, Set<Type>> mapaDeTipos = new AdaptativeHashMap<block, Type>(APIProvider.types);
  
  private final Map<EObject, Type> mapaDeComparacoes = new HashMap<EObject, Type>();
  
  public static <T extends Element> T search(final Set<T> listagem, final T alvo) {
    for (final T elemento : listagem) {
      boolean _equals = elemento.equals(alvo);
      if (_equals) {
        return elemento;
      }
    }
    return null;
  }
  
  public static Procedure searchWithTypeCoersion(final Set<Procedure> listagem, final Procedure alvo) {
    Procedure optimal = null;
    for (final Procedure procedimento : listagem) {
      {
        boolean _equals = procedimento.equals(alvo);
        if (_equals) {
          return procedimento;
        }
        boolean _equalsWithTypeCoersion = procedimento.equalsWithTypeCoersion(alvo);
        if (_equalsWithTypeCoersion) {
          optimal = procedimento;
        }
      }
    }
    return optimal;
  }
  
  public static Type searchByName(final Set<Type> listagem, final Type alvo) {
    for (final Type tipo : listagem) {
      boolean _equals = tipo.name.toLowerCase().equals(alvo.name.toLowerCase());
      if (_equals) {
        return tipo;
      }
    }
    return null;
  }
  
  public boolean insertError(final EObject objeto, final String messagem, final ErrorType tipeErro, final EStructuralFeature feature) {
    Set<org.xtext.ufcg.compiladores.validation.Error> _get = this.mapaDeErros.get(objeto);
    org.xtext.ufcg.compiladores.validation.Error _error = new org.xtext.ufcg.compiladores.validation.Error(messagem, tipeErro, feature);
    return _get.add(_error);
  }
  
  public void removeError(final EObject objeto, final ErrorType tipeErro) {
    Set<org.xtext.ufcg.compiladores.validation.Error> _get = this.mapaDeErros.get(objeto);
    org.xtext.ufcg.compiladores.validation.Error _error = new org.xtext.ufcg.compiladores.validation.Error(tipeErro);
    _get.remove(_error);
    this.showError(objeto);
  }
  
  public <T extends Element> Set<T> clear(final block bloco, final ElementType tipo, final Map<block, Set<T>> container) {
    Set<T> _xblockexpression = null;
    {
      AdaptativeTreeSet<T> newSet = new AdaptativeTreeSet<T>();
      Set<T> _get = container.get(bloco);
      for (final T elemento : _get) {
        if (((!Objects.equal(elemento.type, tipo)) || elemento.isInherited())) {
          newSet.add(elemento);
        }
      }
      _xblockexpression = container.put(bloco, newSet);
    }
    return _xblockexpression;
  }
  
  public ArrayList<Variable> getParameters(final block bloco, final function_designator designator) {
    ArrayList<Variable> parametros = new ArrayList<Variable>();
    expression_list _expressions = designator.getExpressions();
    boolean _notEquals = (!Objects.equal(_expressions, null));
    if (_notEquals) {
      int count = 0;
      EList<expression> _expressions_1 = designator.getExpressions().getExpressions();
      for (final expression expr : _expressions_1) {
        {
          Type _type = this.getType(bloco, expr);
          Variable _variable = new Variable(("arg_" + Integer.valueOf(count)), _type, false, bloco, ElementType.PARAMETER);
          parametros.add(_variable);
          count++;
        }
      }
    }
    return parametros;
  }
  
  public Procedure getAbstraction(final block bloco, final function_designator designator) {
    String nome = designator.getName();
    ArrayList<Variable> parametross = this.getParameters(bloco, designator);
    return new Procedure(nome, parametross);
  }
  
  public String getRealType(final block bloco, final String tipo) {
    Set<Type> _get = this.mapaDeTipos.get(bloco);
    Type _type = new Type(tipo);
    Type tipoEncontrado = PascalValidator.<Type>search(_get, _type);
    boolean _notEquals = (!Objects.equal(tipoEncontrado, null));
    if (_notEquals) {
      return tipoEncontrado.getRealType();
    }
    return tipo;
  }
  
  public Type getType(final block bloco, final String tipo) {
    boolean _equals = Objects.equal(tipo, null);
    if (_equals) {
      return null;
    }
    if (((tipo.length() > 1) && tipo.substring(0, 1).equals(this.POINTER))) {
      Type _type = this.getType(bloco, tipo.substring(1));
      return new ComposedType(_type, ComposedTypeKind.POINTER);
    } else {
      if (((tipo.length() > 9) && tipo.substring(0, 9).equals(this.ARRAY))) {
        Type _type_1 = this.getType(bloco, tipo.substring(9));
        return new ComposedType(_type_1, ComposedTypeKind.ARRAY);
      }
    }
    String _realType = this.getRealType(bloco, tipo);
    return new Type(tipo, false, _realType);
  }
  
  public Type getComposedType(final block bloco, final String tipo, final ComposedTypeKind kind) {
    Type _type = this.getType(bloco, tipo);
    return new ComposedType(_type, kind);
  }
  
  public Type getType(final block bloco, final constant constante) {
    Type paraRetornar = new Type(this.NIL);
    String _name = constante.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      Set<Variable> _get = this.variaveis.get(bloco);
      String _name_1 = constante.getName();
      Variable _variable = new Variable(_name_1);
      Variable varFound = PascalValidator.<Variable>search(_get, _variable);
      boolean _notEquals_1 = (!Objects.equal(varFound, null));
      if (_notEquals_1) {
        paraRetornar = varFound.getVarType();
      }
    } else {
      String _string = constante.getString();
      boolean _notEquals_2 = (!Objects.equal(_string, null));
      if (_notEquals_2) {
        Type _type = new Type(this.CHAR);
        ComposedType _composedType = new ComposedType(_type, ComposedTypeKind.ARRAY);
        paraRetornar = _composedType;
      } else {
        String _boolLiteral = constante.getBoolLiteral();
        boolean _notEquals_3 = (!Objects.equal(_boolLiteral, null));
        if (_notEquals_3) {
          Type _type_1 = new Type(this.BOOLEAN);
          paraRetornar = _type_1;
        } else {
          String _nil = constante.getNil();
          boolean _notEquals_4 = (!Objects.equal(_nil, null));
          if (_notEquals_4) {
            Type _type_2 = new Type(this.NIL);
            paraRetornar = _type_2;
          } else {
            number _number = constante.getNumber();
            boolean _notEquals_5 = (!Objects.equal(_number, null));
            if (_notEquals_5) {
              String _integer = constante.getNumber().getNumber().getInteger();
              boolean _notEquals_6 = (!Objects.equal(_integer, null));
              if (_notEquals_6) {
                Type _type_3 = new Type(this.INTEGER);
                paraRetornar = _type_3;
              } else {
                String _real = constante.getNumber().getNumber().getReal();
                boolean _notEquals_7 = (!Objects.equal(_real, null));
                if (_notEquals_7) {
                  Type _type_4 = new Type(this.REAL);
                  paraRetornar = _type_4;
                }
              }
            }
          }
        }
      }
    }
    return paraRetornar;
  }
  
  public Type getType(final block bloco, final parameter_type tipo) {
    Type paraRetornar = new Type(this.NIL);
    conformant_array_schema _array = tipo.getArray();
    boolean _notEquals = (!Objects.equal(_array, null));
    if (_notEquals) {
      conformant_array_schema array = tipo.getArray();
      packed_conformant_array_schema _packed = array.getPacked();
      boolean _notEquals_1 = (!Objects.equal(_packed, null));
      if (_notEquals_1) {
        Type _type = this.getType(bloco, array.getPacked().getName());
        ComposedType _composedType = new ComposedType(_type, ComposedTypeKind.ARRAY);
        paraRetornar = _composedType;
      } else {
        unpacked_conformant_array_schema _unpacked = array.getUnpacked();
        boolean _notEquals_2 = (!Objects.equal(_unpacked, null));
        if (_notEquals_2) {
          Type _type_1 = this.getType(bloco, array.getUnpacked().getType());
          ComposedType _composedType_1 = new ComposedType(_type_1, ComposedTypeKind.ARRAY);
          paraRetornar = _composedType_1;
        }
      }
    } else {
      String _name = tipo.getName();
      boolean _notEquals_3 = (!Objects.equal(_name, null));
      if (_notEquals_3) {
        Set<Type> _get = this.mapaDeTipos.get(bloco);
        String _name_1 = tipo.getName();
        Type _type_2 = new Type(_name_1);
        Type _search = PascalValidator.<Type>search(_get, _type_2);
        boolean _equals = Objects.equal(_search, null);
        if (_equals) {
          this.insertError(tipo, this.UNDEFINED_TYPE_MESSAGE, ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
        } else {
          this.removeError(tipo, ErrorType.UNDEFINED_TYPE);
        }
        paraRetornar = this.getType(bloco, tipo.getName());
      }
    }
    return paraRetornar;
  }
  
  public Type getType(final block bloco, final type tipo) {
    Type paraRetornar = new Type(this.NIL);
    simple_type _simple = tipo.getSimple();
    boolean _notEquals = (!Objects.equal(_simple, null));
    if (_notEquals) {
      simple_type simple = tipo.getSimple();
      if (((!Objects.equal(simple.getSubrange(), null)) || (!Objects.equal(simple.getEnumerated(), null)))) {
        Type _type = new Type("enumerated", false, "...enumerated");
        paraRetornar = _type;
      } else {
        String _name = simple.getName();
        boolean _notEquals_1 = (!Objects.equal(_name, null));
        if (_notEquals_1) {
          Set<Type> _get = this.mapaDeTipos.get(bloco);
          String _name_1 = simple.getName();
          Type _type_1 = new Type(_name_1);
          Type _search = PascalValidator.<Type>search(_get, _type_1);
          boolean _equals = Objects.equal(_search, null);
          if (_equals) {
            this.insertError(tipo, this.UNDEFINED_TYPE_MESSAGE, ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
          } else {
            this.removeError(tipo, ErrorType.UNDEFINED_TYPE);
          }
          paraRetornar = this.getType(bloco, simple.getName());
        }
      }
    } else {
      structured_type _structured = tipo.getStructured();
      boolean _notEquals_2 = (!Objects.equal(_structured, null));
      if (_notEquals_2) {
        structured_type structured = tipo.getStructured();
        unpacked_structured_type unpacked = structured.getType();
        array_type _array = unpacked.getArray();
        boolean _notEquals_3 = (!Objects.equal(_array, null));
        if (_notEquals_3) {
          Type _type_2 = this.getType(bloco, unpacked.getArray().getType());
          ComposedType _composedType = new ComposedType(_type_2, ComposedTypeKind.ARRAY);
          paraRetornar = _composedType;
        } else {
          record_type _record = unpacked.getRecord();
          boolean _notEquals_4 = (!Objects.equal(_record, null));
          if (_notEquals_4) {
            Type _type_3 = new Type(this.RECORD);
            paraRetornar = _type_3;
          } else {
            set_type _set = unpacked.getSet();
            boolean _notEquals_5 = (!Objects.equal(_set, null));
            if (_notEquals_5) {
              paraRetornar = this.getType(bloco, unpacked.getSet().getType());
            } else {
              file_type _file = unpacked.getFile();
              boolean _notEquals_6 = (!Objects.equal(_file, null));
              if (_notEquals_6) {
                paraRetornar = this.getType(bloco, unpacked.getFile().getType());
              }
            }
          }
        }
      } else {
        pointer_type _pointer = tipo.getPointer();
        boolean _notEquals_7 = (!Objects.equal(_pointer, null));
        if (_notEquals_7) {
          Type _type_4 = this.getType(bloco, tipo.getPointer().getType());
          ComposedType _composedType_1 = new ComposedType(_type_4, ComposedTypeKind.POINTER);
          paraRetornar = _composedType_1;
        }
      }
    }
    return paraRetornar;
  }
  
  public Type getType(final block bloco, final variable variavel) {
    Type paraRetornar = new Type(this.NIL);
    Set<Variable> _get = this.variaveis.get(bloco);
    String _name = variavel.getName();
    Variable _variable = new Variable(_name);
    Variable resultadoBusca = PascalValidator.<Variable>search(_get, _variable);
    boolean _notEquals = (!Objects.equal(resultadoBusca, null));
    if (_notEquals) {
      paraRetornar = resultadoBusca.getVarType();
    }
    return paraRetornar;
  }
  
  public Type getType(final block bloco, final factor fator) {
    Type paraRetornar = new Type(this.NIL);
    variable _variable = fator.getVariable();
    boolean _notEquals = (!Objects.equal(_variable, null));
    if (_notEquals) {
      Set<Variable> _get = this.variaveis.get(bloco);
      String _name = fator.getVariable().getName();
      Variable _variable_1 = new Variable(_name);
      Variable resultadoBusca = PascalValidator.<Variable>search(_get, _variable_1);
      boolean _notEquals_1 = (!Objects.equal(resultadoBusca, null));
      if (_notEquals_1) {
        paraRetornar = resultadoBusca.getVarType();
      }
    } else {
      number _number = fator.getNumber();
      boolean _notEquals_2 = (!Objects.equal(_number, null));
      if (_notEquals_2) {
        any_number number = fator.getNumber().getNumber();
        String _integer = number.getInteger();
        boolean _notEquals_3 = (!Objects.equal(_integer, null));
        if (_notEquals_3) {
          Type _type = new Type(this.INTEGER);
          paraRetornar = _type;
        } else {
          String _real = number.getReal();
          boolean _notEquals_4 = (!Objects.equal(_real, null));
          if (_notEquals_4) {
            Type _type_1 = new Type(this.REAL);
            paraRetornar = _type_1;
          }
        }
      } else {
        String _string = fator.getString();
        boolean _notEquals_5 = (!Objects.equal(_string, null));
        if (_notEquals_5) {
          Type _type_2 = new Type(this.CHAR);
          ComposedType _composedType = new ComposedType(_type_2, ComposedTypeKind.ARRAY);
          paraRetornar = _composedType;
        } else {
          set _set = fator.getSet();
          boolean _notEquals_6 = (!Objects.equal(_set, null));
          if (_notEquals_6) {
            paraRetornar = this.getType(bloco, fator.getSet().getExpressions(), true);
          } else {
            boolean _isNil = fator.isNil();
            if (_isNil) {
              Type _type_3 = new Type(this.NIL);
              paraRetornar = _type_3;
            } else {
              if (((!Objects.equal(fator.getBoolean(), null)) || (!Objects.equal(fator.getNot(), null)))) {
                Type _type_4 = new Type(this.BOOLEAN);
                paraRetornar = _type_4;
              } else {
                function_designator _function = fator.getFunction();
                boolean _notEquals_7 = (!Objects.equal(_function, null));
                if (_notEquals_7) {
                  paraRetornar = this.getType(bloco, fator.getFunction());
                } else {
                  expression _expression = fator.getExpression();
                  boolean _notEquals_8 = (!Objects.equal(_expression, null));
                  if (_notEquals_8) {
                    paraRetornar = this.getType(bloco, fator.getExpression());
                  }
                }
              }
            }
          }
        }
      }
    }
    this.mapaDeComparacoes.put(fator, paraRetornar);
    return paraRetornar;
  }
  
  public Type getType(final block bloco, final function_designator designator) {
    Type paraRetornar = new Type(this.NIL);
    Procedure funcao = this.getAbstraction(bloco, designator);
    Procedure resultadoBusca = PascalValidator.searchWithTypeCoersion(this.procedimentos.get(bloco), funcao);
    if (((!Objects.equal(resultadoBusca, null)) && Objects.equal(resultadoBusca.type, ElementType.FUNCTION))) {
      Function functionFound = ((Function) resultadoBusca);
      paraRetornar = functionFound.getReturnType();
    }
    return paraRetornar;
  }
  
  public Type getType(final block bloco, final term termo) {
    Type paraRetornar = null;
    EList<factor> _factors = termo.getFactors();
    for (final factor f : _factors) {
      {
        Type tipo = this.getType(bloco, f);
        paraRetornar = TypeInferer.greater(tipo, paraRetornar);
      }
    }
    this.mapaDeComparacoes.put(termo, paraRetornar);
    return paraRetornar;
  }
  
  public Type getType(final block bloco, final expression expressao) {
    Type paraRetornar = new Type(this.NIL);
    if (((!Objects.equal(expressao.getOperators(), null)) && (!expressao.getOperators().isEmpty()))) {
      Type _type = new Type(this.BOOLEAN);
      paraRetornar = _type;
    } else {
      Type greatestType = null;
      EList<simple_expression> _expressions = expressao.getExpressions();
      for (final simple_expression e : _expressions) {
        {
          Type type = this.getType(bloco, e);
          greatestType = TypeInferer.greater(type, greatestType);
        }
      }
      paraRetornar = greatestType;
    }
    this.mapaDeComparacoes.put(expressao, paraRetornar);
    return paraRetornar;
  }
  
  public Type getType(final block bloco, final simple_expression expressao) {
    Type paraRetornar = null;
    EList<EObject> _terms = expressao.getTerms();
    for (final EObject obj : _terms) {
      if ((obj instanceof term)) {
        term termo = ((term) obj);
        Type tipo = this.getType(bloco, termo);
        paraRetornar = TypeInferer.greater(tipo, paraRetornar);
      } else {
        any_number numero = ((any_number) obj);
        String _integer = numero.getInteger();
        boolean _notEquals = (!Objects.equal(_integer, null));
        if (_notEquals) {
          Type _type = new Type(this.INTEGER);
          paraRetornar = TypeInferer.greater(_type, paraRetornar);
        } else {
          Type _type_1 = new Type(this.REAL);
          paraRetornar = TypeInferer.greater(_type_1, paraRetornar);
        }
      }
    }
    this.mapaDeComparacoes.put(expressao, paraRetornar);
    return paraRetornar;
  }
  
  public Type getType(final block bloco, final expression_list expressoes, final boolean temCoesao) {
    Type paraRetornar = null;
    boolean temErro = true;
    EList<expression> _expressions = expressoes.getExpressions();
    for (final expression expressao : _expressions) {
      {
        Type tipo = this.getType(bloco, expressao);
        if (temCoesao) {
          if (((((!Objects.equal(paraRetornar, null)) && (TypeInferer.getTypeWeight(paraRetornar) < 0)) && (TypeInferer.getTypeWeight(tipo) >= 0)) || 
            ((TypeInferer.getTypeWeight(tipo) < 0) && (TypeInferer.getTypeWeight(paraRetornar) >= 0)))) {
            this.insertError(expressoes, ((((this.CANNOT_CONVERT_MESSAGE + tipo) + this.TO_MESSAGE) + paraRetornar) + "."), ErrorType.TYPE_COHESION, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
            temErro = true;
          }
        }
        paraRetornar = TypeInferer.greater(tipo, paraRetornar);
      }
    }
    if ((!temErro)) {
      this.removeError(expressoes, ErrorType.TYPE_COHESION);
    }
    this.mapaDeComparacoes.put(expressoes, paraRetornar);
    return paraRetornar;
  }
  
  public static boolean isNumeric(final Object objeto) {
    try {
      Double.parseDouble(objeto.toString());
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    return true;
  }
  
  public static Object getValue(final number numero) {
    String _integer = numero.getNumber().getInteger();
    boolean _notEquals = (!Objects.equal(_integer, null));
    if (_notEquals) {
      return Integer.valueOf(numero.getNumber().getInteger());
    } else {
      String _real = numero.getNumber().getReal();
      boolean _notEquals_1 = (!Objects.equal(_real, null));
      if (_notEquals_1) {
        return Double.valueOf(numero.getNumber().getReal());
      }
    }
    return null;
  }
  
  public static Object getValue(final constant constante, final Set<Variable> variables) {
    Object paraRetornar = null;
    String _name = constante.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      String _name_1 = constante.getName();
      Variable _variable = new Variable(_name_1);
      Variable variable = PascalValidator.<Variable>search(variables, _variable);
      paraRetornar = variable.getValue();
    } else {
      number _number = constante.getNumber();
      boolean _notEquals_1 = (!Objects.equal(_number, null));
      if (_notEquals_1) {
        paraRetornar = PascalValidator.getValue(constante.getNumber());
      } else {
        String _string = constante.getString();
        boolean _notEquals_2 = (!Objects.equal(_string, null));
        if (_notEquals_2) {
          paraRetornar = constante.getString();
        } else {
          String _boolLiteral = constante.getBoolLiteral();
          boolean _notEquals_3 = (!Objects.equal(_boolLiteral, null));
          if (_notEquals_3) {
            paraRetornar = Boolean.valueOf(constante.getBoolLiteral());
          } else {
            String _nil = constante.getNil();
            boolean _notEquals_4 = (!Objects.equal(_nil, null));
            if (_notEquals_4) {
              paraRetornar = null;
            }
          }
        }
      }
    }
    String _opterator = constante.getOpterator();
    boolean _notEquals_5 = (!Objects.equal(_opterator, null));
    if (_notEquals_5) {
      if ((PascalValidator.isNumeric(paraRetornar) && constante.getOpterator().equals("-"))) {
        try {
          int _parseInt = Integer.parseInt(paraRetornar.toString());
          return Integer.valueOf((-_parseInt));
        } catch (final Throwable _t) {
          if (_t instanceof Exception) {
            final Exception e = (Exception)_t;
            double _parseDouble = Double.parseDouble(paraRetornar.toString());
            return Double.valueOf((-_parseDouble));
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
      }
    }
    return paraRetornar;
  }
  
  public <T extends Element> Boolean addElement(final block bloco, final T elemento, final Map<block, Set<T>> container, final EObject errorSection, final EStructuralFeature errorFeature) {
    boolean _xblockexpression = false;
    {
      T resultadoBusca = null;
      boolean _equals = Objects.equal(container, this.mapaDeTipos);
      if (_equals) {
        Type tipo = ((Type) elemento);
        Type _searchByName = PascalValidator.searchByName(this.mapaDeTipos.get(bloco), tipo);
        resultadoBusca = ((T) _searchByName);
      } else {
        resultadoBusca = PascalValidator.<T>search(container.get(bloco), elemento);
      }
      boolean _xifexpression = false;
      if (((!Objects.equal(resultadoBusca, null)) && (!resultadoBusca.isInherited()))) {
        boolean _xifexpression_1 = false;
        boolean _equals_1 = Objects.equal(elemento.type, resultadoBusca.type);
        if (_equals_1) {
          String _plus = (elemento.type + this.CANNOT_REDECLARE);
          _xifexpression_1 = this.insertError(errorSection, _plus, ErrorType.REDECLARATION, errorFeature);
        } else {
          boolean _xifexpression_2 = false;
          boolean _equals_2 = Objects.equal(resultadoBusca.type, ElementType.FUNCTION_RETURN);
          if (_equals_2) {
            _xifexpression_2 = this.insertError(errorSection, this.ID_FUNC_RETURN, ErrorType.REDECLARATION, errorFeature);
          } else {
            String _lowerCase = resultadoBusca.type.toString().toLowerCase();
            String _plus_1 = (this.ID_IN_USE + _lowerCase);
            String _plus_2 = (_plus_1 + ".");
            _xifexpression_2 = this.insertError(errorSection, _plus_2, ErrorType.REDECLARATION, errorFeature);
          }
          _xifexpression_1 = _xifexpression_2;
        }
        _xifexpression = _xifexpression_1;
      } else {
        this.removeError(errorSection, ErrorType.REDECLARATION);
        container.get(bloco).add(elemento);
        Element _clone = elemento.clone();
        T elementoHerdado = ((T) _clone);
        elementoHerdado.inherited = true;
        this.<T>inheritElement(bloco, elementoHerdado, container);
      }
      _xblockexpression = _xifexpression;
    }
    return Boolean.valueOf(_xblockexpression);
  }
  
  public <T extends Element> void inheritElement(final block bloco, final T elemento, final Map<block, Set<T>> container) {
    procedure_and_function_declaration_part _abstraction = bloco.getDeclaration().getAbstraction();
    boolean _notEquals = (!Objects.equal(_abstraction, null));
    if (_notEquals) {
      EList<abstraction_heading> _procedures = bloco.getDeclaration().getAbstraction().getProcedures();
      boolean _notEquals_1 = (!Objects.equal(_procedures, null));
      if (_notEquals_1) {
        EList<abstraction_heading> _procedures_1 = bloco.getDeclaration().getAbstraction().getProcedures();
        for (final abstraction_declaration procedure : _procedures_1) {
          this.<T>addElementToAbstraction(procedure, elemento, container);
        }
      }
      EList<abstraction_declaration> _functions = bloco.getDeclaration().getAbstraction().getFunctions();
      boolean _notEquals_2 = (!Objects.equal(_functions, null));
      if (_notEquals_2) {
        EList<abstraction_declaration> _functions_1 = bloco.getDeclaration().getAbstraction().getFunctions();
        for (final abstraction_declaration function : _functions_1) {
          this.<T>addElementToAbstraction(function, elemento, container);
        }
      }
    }
  }
  
  public <T extends Element> boolean addElementToAbstraction(final abstraction_declaration declaracao, final T elemento, final Map<block, Set<T>> container) {
    boolean _xblockexpression = false;
    {
      block _block = declaracao.getBlock();
      boolean _equals = Objects.equal(_block, null);
      if (_equals) {
        declaracao.setBlock(PascalPackage.eINSTANCE.getPascalFactory().createblock());
      }
      block subBloco = declaracao.getBlock();
      _xblockexpression = container.get(subBloco).add(elemento);
    }
    return _xblockexpression;
  }
  
  public ArrayList<Variable> getParameters(final block bloco, final abstraction_heading heading, final block abstractionBlock) {
    ArrayList<Variable> parametros = new ArrayList<Variable>();
    formal_parameter_list _parameters = heading.getParameters();
    boolean _notEquals = (!Objects.equal(_parameters, null));
    if (_notEquals) {
      formal_parameter_list listagem = heading.getParameters();
      EList<formal_parameter_section> _parameters_1 = listagem.getParameters();
      boolean _notEquals_1 = (!Objects.equal(_parameters_1, null));
      if (_notEquals_1) {
        EList<formal_parameter_section> _parameters_2 = listagem.getParameters();
        for (final formal_parameter_section sessao : _parameters_2) {
          variable_parameter_section _variable = sessao.getVariable();
          boolean _notEquals_2 = (!Objects.equal(_variable, null));
          if (_notEquals_2) {
            variable_parameter_section variavel = sessao.getVariable();
            EList<String> _ids = variavel.getIdentifiers().getIds();
            for (final String varName : _ids) {
              {
                Type _type = this.getType(bloco, sessao.getVariable().getType());
                Variable parametro = new Variable(varName, _type, false, abstractionBlock, ElementType.PARAMETER);
                this.<Variable>addElement(bloco, parametro, this.variaveis, variavel, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
                parametros.add(parametro);
              }
            }
          } else {
            value_parameter_section _value = sessao.getValue();
            boolean _notEquals_3 = (!Objects.equal(_value, null));
            if (_notEquals_3) {
              value_parameter_section valor = sessao.getValue();
              EList<String> _ids_1 = valor.getIdentifiers().getIds();
              for (final String nomeValor : _ids_1) {
                {
                  Type _type = this.getType(bloco, valor.getType());
                  Variable parametro = new Variable(nomeValor, _type, false, abstractionBlock, ElementType.PARAMETER);
                  this.<Variable>addElement(bloco, parametro, this.variaveis, valor, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
                  parametros.add(parametro);
                }
              }
            }
          }
        }
      }
    }
    return parametros;
  }
  
  public Boolean addAbstraction(final block bloco, final abstraction_declaration declaracao, final abstraction_heading heading) {
    Boolean _xblockexpression = null;
    {
      String nome = heading.getName();
      block _block = declaracao.getBlock();
      boolean _equals = Objects.equal(_block, null);
      if (_equals) {
        declaracao.setBlock(PascalPackage.eINSTANCE.getPascalFactory().createblock());
      }
      this.<Variable>clear(declaracao.getBlock(), ElementType.PARAMETER, this.variaveis);
      ArrayList<Variable> parametro = this.getParameters(declaracao.getBlock(), heading, declaracao.getBlock());
      boolean proximo = declaracao.isForward();
      String tipoDoRetorno = heading.getResultType();
      Boolean _xifexpression = null;
      boolean _notEquals = (!Objects.equal(tipoDoRetorno, null));
      if (_notEquals) {
        boolean _xblockexpression_1 = false;
        {
          Set<Type> _get = this.mapaDeTipos.get(bloco);
          Type _type = new Type(tipoDoRetorno);
          Type _search = PascalValidator.<Type>search(_get, _type);
          boolean _equals_1 = Objects.equal(_search, null);
          if (_equals_1) {
            this.insertError(heading, this.UNDEFINED_TYPE_MESSAGE, ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RESULT_TYPE);
          } else {
            this.removeError(heading, ErrorType.UNDEFINED_TYPE);
          }
          Type _type_1 = this.getType(bloco, tipoDoRetorno);
          Function funcao = new Function(nome, proximo, bloco, declaracao, parametro, proximo, _type_1);
          this.<Procedure>addElement(bloco, funcao, this.procedimentos, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
          Type _type_2 = this.getType(bloco, tipoDoRetorno);
          block _block_1 = declaracao.getBlock();
          Variable variavelRetorno = new Variable(nome, _type_2, false, _block_1, ElementType.FUNCTION_RETURN);
          variavelRetorno.setOwningFunction(funcao);
          _xblockexpression_1 = this.variaveis.get(declaracao.getBlock()).add(variavelRetorno);
        }
        _xifexpression = Boolean.valueOf(_xblockexpression_1);
      } else {
        Procedure _procedure = new Procedure(nome, proximo, bloco, declaracao, parametro, proximo);
        _xifexpression = this.<Procedure>addElement(bloco, _procedure, this.procedimentos, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public void checkAbstractionRedeclaration(final block bloco) {
    procedure_and_function_declaration_part _abstraction = bloco.getDeclaration().getAbstraction();
    boolean _notEquals = (!Objects.equal(_abstraction, null));
    if (_notEquals) {
      this.<Procedure>clear(bloco, ElementType.FUNCTION, this.procedimentos);
      this.<Procedure>clear(bloco, ElementType.PROCEDURE, this.procedimentos);
      procedure_and_function_declaration_part abstracao = bloco.getDeclaration().getAbstraction();
      EList<abstraction_declaration> _functions = abstracao.getFunctions();
      boolean _notEquals_1 = (!Objects.equal(_functions, null));
      if (_notEquals_1) {
        EList<abstraction_declaration> _functions_1 = abstracao.getFunctions();
        for (final abstraction_declaration function : _functions_1) {
          this.addAbstraction(bloco, function, function.getHeading());
        }
      }
      EList<abstraction_heading> _procedures = abstracao.getProcedures();
      boolean _notEquals_2 = (!Objects.equal(_procedures, null));
      if (_notEquals_2) {
        EList<abstraction_heading> _procedures_1 = abstracao.getProcedures();
        for (final abstraction_declaration procedure : _procedures_1) {
          this.addAbstraction(bloco, procedure, procedure.getHeading());
        }
      }
    }
  }
  
  public void checkTypeRedeclaration(final block bloco) {
    this.<Type>clear(bloco, ElementType.TYPE, this.mapaDeTipos);
    type_definition_part _type_def = bloco.getDeclaration().getType_def();
    boolean _notEquals = (!Objects.equal(_type_def, null));
    if (_notEquals) {
      EList<type_definition> _types = bloco.getDeclaration().getType_def().getTypes();
      for (final type_definition definicao : _types) {
        String _name = definicao.getName();
        String _realType = this.getType(bloco, definicao.getType()).getRealType();
        Type _type = new Type(_name, false, _realType);
        this.<Type>addElement(bloco, _type, this.mapaDeTipos, definicao, PascalPackage.Literals.TYPE_DEFINITION__NAME);
      }
    }
  }
  
  public void checkConstantRedeclaration(final block bloco) {
    this.<Variable>clear(bloco, ElementType.CONSTANT, this.variaveis);
    constant_definition_part _constant_def = bloco.getDeclaration().getConstant_def();
    boolean _notEquals = (!Objects.equal(_constant_def, null));
    if (_notEquals) {
      EList<constant_definition> _consts = bloco.getDeclaration().getConstant_def().getConsts();
      for (final constant_definition constante : _consts) {
        String _name = constante.getName();
        Type _type = this.getType(bloco, constante.getConst());
        Object _value = PascalValidator.getValue(constante.getConst(), this.variaveis.get(bloco));
        Variable _variable = new Variable(_name, _type, false, bloco, ElementType.CONSTANT, _value);
        this.<Variable>addElement(bloco, _variable, this.variaveis, constante, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
      }
    }
  }
  
  public void checkVariableRedeclaration(final block bloco) {
    this.<Variable>clear(bloco, ElementType.VARIABLE, this.variaveis);
    variable_declaration_part _variable_decl = bloco.getDeclaration().getVariable_decl();
    boolean _notEquals = (!Objects.equal(_variable_decl, null));
    if (_notEquals) {
      EList<variable_section> _sections = bloco.getDeclaration().getVariable_decl().getSections();
      for (final variable_section sessao : _sections) {
        EList<String> _names = sessao.getIdentifiers().getNames();
        for (final String nome : _names) {
          {
            Type tipo = this.getType(bloco, sessao.getType());
            Variable _variable = new Variable(nome, tipo, false, bloco, ElementType.VARIABLE);
            this.<Variable>addElement(bloco, _variable, this.variaveis, sessao, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
          }
        }
      }
    }
  }
  
  public boolean checkVariable(final block bloco, final variable Variavel, final boolean ehAtribuicao) {
    boolean ehValido = true;
    boolean _equals = Objects.equal(Variavel, null);
    if (_equals) {
      return true;
    }
    Set<Variable> _get = this.variaveis.get(bloco);
    String _name = Variavel.getName();
    Variable _variable = new Variable(_name);
    Variable resultadoBusca = PascalValidator.<Variable>search(_get, _variable);
    boolean _equals_1 = Objects.equal(resultadoBusca, null);
    if (_equals_1) {
      ehValido = false;
      this.insertError(Variavel, this.VAR_NOT_DECL, ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
    } else {
      this.removeError(Variavel, ErrorType.NOT_DECLARATION);
      if (ehAtribuicao) {
        boolean _equals_2 = Objects.equal(resultadoBusca.type, ElementType.CONSTANT);
        if (_equals_2) {
          ehValido = false;
          this.insertError(Variavel, this.CONST_CNOT_ASSIGN, ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
        } else {
          this.removeError(Variavel, ErrorType.CONSTANT_ASSIGNMENT);
        }
      }
    }
    return ehValido;
  }
  
  public void checkAbstraction(final block bloco, final Procedure procedimento, final boolean ahApenasFuncao, final EObject objeto, final EStructuralFeature feature) {
    Procedure resultadoBusca = PascalValidator.searchWithTypeCoersion(this.procedimentos.get(bloco), procedimento);
    boolean _equals = Objects.equal(resultadoBusca, null);
    if (_equals) {
      Set<Procedure> _get = this.procedimentos.get(bloco);
      for (final Procedure outroProcedimento : _get) {
        boolean _equals_1 = outroProcedimento.name.toLowerCase().equals(procedimento.name.toLowerCase());
        if (_equals_1) {
          int _size = outroProcedimento.parameters.size();
          int _size_1 = procedimento.parameters.size();
          boolean _notEquals = (_size != _size_1);
          if (_notEquals) {
            int _size_2 = outroProcedimento.parameters.size();
            String _plus = (this.ARG_WRONG_NUM + Integer.valueOf(_size_2));
            String _plus_1 = (_plus + this.RECEIVED);
            int _size_3 = procedimento.parameters.size();
            String _plus_2 = (_plus_1 + Integer.valueOf(_size_3));
            String _plus_3 = (_plus_2 + this.ARGS);
            this.insertError(objeto, _plus_3, ErrorType.NOT_DECLARATION, feature);
          } else {
            Iterator<Variable> it1 = outroProcedimento.parameters.iterator();
            Iterator<Variable> it2 = procedimento.parameters.iterator();
            while ((it1.hasNext() && it2.hasNext())) {
              {
                Variable type1 = it1.next();
                Variable type2 = it2.next();
                boolean _areTypesCompatibles = TypeInferer.areTypesCompatibles(type1.getVarType(), type2.getVarType());
                boolean _not = (!_areTypesCompatibles);
                if (_not) {
                  this.insertError(objeto, ((((this.INCOMPATIBLE_TYPES + outroProcedimento.parameters) + this.RECEIVED) + procedimento.parameters) + "."), ErrorType.NOT_DECLARATION, feature);
                  return;
                }
              }
            }
          }
          return;
        }
      }
      this.insertError(objeto, this.FUNC_NOT_DECL, ErrorType.NOT_DECLARATION, feature);
    } else {
      this.removeError(objeto, ErrorType.NOT_DECLARATION);
      if ((Objects.equal(resultadoBusca.type, ElementType.PROCEDURE) && ahApenasFuncao)) {
        this.insertError(objeto, this.FUNC_ONLY, ErrorType.FUNCTION_ONLY, feature);
      } else {
        this.removeError(objeto, ErrorType.FUNCTION_ONLY);
      }
    }
  }
  
  public void checkAbstractionCall(final block bloco, final function_designator designator, final boolean ahApenasFuncao) {
    expression_list _expressions = designator.getExpressions();
    boolean _notEquals = (!Objects.equal(_expressions, null));
    if (_notEquals) {
      EList<expression> _expressions_1 = designator.getExpressions().getExpressions();
      for (final expression expressao : _expressions_1) {
        this.checkExpression(bloco, expressao);
      }
    }
    this.checkAbstraction(bloco, this.getAbstraction(bloco, designator), ahApenasFuncao, designator, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME);
  }
  
  public void checkFactor(final block bloco, final factor fator) {
    variable _variable = fator.getVariable();
    boolean _notEquals = (!Objects.equal(_variable, null));
    if (_notEquals) {
      this.checkVariable(bloco, fator.getVariable(), false);
      boolean _containsKey = this.variaveis.containsKey(bloco);
      if (_containsKey) {
        Set<Variable> _get = this.variaveis.get(bloco);
        String _name = fator.getVariable().getName();
        Variable _variable_1 = new Variable(_name);
        Variable resultadoBusca = PascalValidator.<Variable>search(_get, _variable_1);
        if (((!Objects.equal(resultadoBusca, null)) && Objects.equal(resultadoBusca.getValue(), null))) {
          this.insertError(fator, this.VAR_NOT_INIT, ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
        } else {
          this.removeError(fator, ErrorType.NOT_INITIALIZED);
        }
      }
    } else {
      function_designator _function = fator.getFunction();
      boolean _notEquals_1 = (!Objects.equal(_function, null));
      if (_notEquals_1) {
        this.checkAbstractionCall(bloco, fator.getFunction(), true);
      } else {
        factor _not = fator.getNot();
        boolean _notEquals_2 = (!Objects.equal(_not, null));
        if (_notEquals_2) {
          boolean _equals = this.getType(bloco, fator.getNot()).getRealType().toLowerCase().equals(this.BOOLEAN);
          boolean _not_1 = (!_equals);
          if (_not_1) {
            Type _type = this.getType(bloco, fator.getNot());
            String _plus = (this.CANNOT_CONVERT_MESSAGE + _type);
            String _plus_1 = (_plus + this.TO_BOOL);
            this.insertError(fator, _plus_1, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
          } else {
            this.removeError(fator, ErrorType.TYPE_CONVERSION_ERROR);
          }
          this.checkFactor(bloco, fator.getNot());
        } else {
          expression _expression = fator.getExpression();
          boolean _notEquals_3 = (!Objects.equal(_expression, null));
          if (_notEquals_3) {
            this.checkExpression(bloco, fator.getExpression());
          }
        }
      }
    }
  }
  
  public void checkTerm(final block bloco, final term termo) {
    boolean ehBooleano = false;
    boolean ehNumeral = false;
    EList<String> _operators = termo.getOperators();
    boolean _notEquals = (!Objects.equal(_operators, null));
    if (_notEquals) {
      EList<String> _operators_1 = termo.getOperators();
      for (final String operador : _operators_1) {
        boolean _equals = operador.toLowerCase().equals("and");
        if (_equals) {
          ehBooleano = true;
        } else {
          if ((!ehBooleano)) {
            ehNumeral = true;
          } else {
            this.insertError(termo, this.INVALID_OP, ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);
            return;
          }
        }
      }
    }
    this.removeError(termo, ErrorType.INVALID_OPERATOR);
    EList<factor> _factors = termo.getFactors();
    for (final factor fator : _factors) {
      {
        if (ehBooleano) {
          boolean _equals_1 = this.getType(bloco, fator).getRealType().toLowerCase().equals(this.BOOLEAN);
          boolean _not = (!_equals_1);
          if (_not) {
            Type _type = this.getType(bloco, fator);
            String _plus = (this.CANNOT_CONVERT_MESSAGE + _type);
            String _plus_1 = (_plus + this.TO_BOOL);
            this.insertError(termo, _plus_1, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);
          } else {
            this.removeError(termo, ErrorType.TYPE_CONVERSION_ERROR);
          }
        } else {
          if (ehNumeral) {
            int _typeWeight = TypeInferer.getTypeWeight(this.getType(bloco, fator));
            boolean _equals_2 = (_typeWeight == (-1));
            if (_equals_2) {
              Type _type_1 = this.getType(bloco, fator);
              String _plus_2 = (this.CANNOT_CONVERT_MESSAGE + _type_1);
              String _plus_3 = (_plus_2 + this.TO_NUM);
              this.insertError(termo, _plus_3, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);
            } else {
              this.removeError(termo, ErrorType.TYPE_CONVERSION_ERROR);
            }
          }
        }
        this.checkFactor(bloco, fator);
      }
    }
  }
  
  public void checkExpression(final block bloco, final expression expressao) {
    EList<simple_expression> _expressions = expressao.getExpressions();
    for (final simple_expression outraExpressao : _expressions) {
      {
        boolean ehBooleano = false;
        boolean ehNumeral = false;
        String _prefixOperator = outraExpressao.getPrefixOperator();
        boolean _notEquals = (!Objects.equal(_prefixOperator, null));
        if (_notEquals) {
          ehNumeral = true;
        }
        EList<String> _operators = outraExpressao.getOperators();
        boolean _notEquals_1 = (!Objects.equal(_operators, null));
        if (_notEquals_1) {
          EList<String> _operators_1 = outraExpressao.getOperators();
          for (final String operador : _operators_1) {
            boolean _equals = operador.toLowerCase().equals("or");
            if (_equals) {
              ehBooleano = true;
            } else {
              if ((!ehBooleano)) {
                ehNumeral = true;
              } else {
                this.insertError(outraExpressao, this.INVALID_OP, ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);
                return;
              }
            }
          }
        }
        if ((ehNumeral && ehBooleano)) {
          this.insertError(outraExpressao, this.NUM_ONLY, ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);
        } else {
          this.removeError(outraExpressao, ErrorType.INVALID_OPERATOR);
          EList<EObject> _terms = outraExpressao.getTerms();
          for (final EObject objeto : _terms) {
            if ((objeto instanceof term)) {
              term termo = ((term) objeto);
              if (ehBooleano) {
                boolean _equals_1 = this.getType(bloco, termo).getRealType().toLowerCase().equals(this.BOOLEAN);
                boolean _not = (!_equals_1);
                if (_not) {
                  Type _type = this.getType(bloco, termo);
                  String _plus = (this.CANNOT_CONVERT_MESSAGE + _type);
                  String _plus_1 = (_plus + this.TO_BOOL);
                  this.insertError(outraExpressao, _plus_1, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
                } else {
                  this.removeError(outraExpressao, ErrorType.TYPE_CONVERSION_ERROR);
                }
              } else {
                if (ehNumeral) {
                  int _typeWeight = TypeInferer.getTypeWeight(this.getType(bloco, termo));
                  boolean _equals_2 = (_typeWeight == (-1));
                  if (_equals_2) {
                    Type _type_1 = this.getType(bloco, termo);
                    String _plus_2 = (this.CANNOT_CONVERT_MESSAGE + _type_1);
                    String _plus_3 = (_plus_2 + this.TO_NUM);
                    this.insertError(outraExpressao, _plus_3, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
                  } else {
                    this.removeError(outraExpressao, ErrorType.TYPE_CONVERSION_ERROR);
                  }
                }
              }
              this.checkTerm(bloco, termo);
            } else {
              if ((!ehNumeral)) {
                this.insertError(outraExpressao, this.NUM_ONLY, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
              } else {
                this.removeError(outraExpressao, ErrorType.TYPE_CONVERSION_ERROR);
              }
            }
          }
        }
      }
    }
  }
  
  public Boolean checkConstant(final block bloco, final constant constante) {
    boolean _xifexpression = false;
    String _name = constante.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (_notEquals) {
      boolean _xblockexpression = false;
      {
        Set<Variable> _get = this.variaveis.get(bloco);
        String _name_1 = constante.getName();
        Variable _variable = new Variable(_name_1);
        Variable resultadoBusca = PascalValidator.<Variable>search(_get, _variable);
        boolean _xifexpression_1 = false;
        boolean _equals = Objects.equal(resultadoBusca, null);
        if (_equals) {
          _xifexpression_1 = this.insertError(constante, this.CONST_NOT_DECL, ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
        } else {
          boolean _xblockexpression_1 = false;
          {
            this.removeError(constante, ErrorType.NOT_DECLARATION);
            boolean _notEquals_1 = (!Objects.equal(resultadoBusca.type, ElementType.CONSTANT));
            if (_notEquals_1) {
              this.insertError(constante, this.CONST_ONLY, ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
            } else {
              this.removeError(constante, ErrorType.CONSTANT_ONLY);
            }
            boolean _xifexpression_2 = false;
            if (((!Objects.equal(constante.getOpterator(), null)) && (TypeInferer.getTypeWeight(resultadoBusca.getVarType()) < 0))) {
              _xifexpression_2 = this.insertError(constante, this.NAN, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.CONSTANT__NAME);
            } else {
              this.removeError(constante, ErrorType.TYPE_CONVERSION_ERROR);
            }
            _xblockexpression_1 = _xifexpression_2;
          }
          _xifexpression_1 = _xblockexpression_1;
        }
        _xblockexpression = _xifexpression_1;
      }
      _xifexpression = _xblockexpression;
    }
    return Boolean.valueOf(_xifexpression);
  }
  
  public void checkStatement(final block bloco, final statement declaracao) {
    simple_statement _simple = declaracao.getSimple();
    boolean _notEquals = (!Objects.equal(_simple, null));
    if (_notEquals) {
      simple_statement simples = declaracao.getSimple();
      assignment_statement _assignment = simples.getAssignment();
      boolean _notEquals_1 = (!Objects.equal(_assignment, null));
      if (_notEquals_1) {
        boolean _checkVariable = this.checkVariable(bloco, simples.getAssignment().getVariable(), true);
        if (_checkVariable) {
          Type tipoVariavel = this.getType(bloco, simples.getAssignment().getVariable());
          Type tipoExpressao = this.getType(bloco, simples.getAssignment().getExpression());
          boolean _areTypesCompatibles = TypeInferer.areTypesCompatibles(tipoVariavel, tipoExpressao);
          boolean _not = (!_areTypesCompatibles);
          if (_not) {
            this.insertError(simples.getAssignment(), ((((this.CANNOT_CONVERT_MESSAGE + tipoExpressao) + this.TO_MESSAGE) + tipoVariavel) + "."), ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
          } else {
            this.removeError(simples.getAssignment(), ErrorType.TYPE_CONVERSION_ERROR);
          }
          this.checkExpression(bloco, simples.getAssignment().getExpression());
          Set<Variable> _get = this.variaveis.get(bloco);
          String _name = simples.getAssignment().getVariable().getName();
          Variable _variable = new Variable(_name);
          Variable resultadoBusca = PascalValidator.<Variable>search(_get, _variable);
          boolean _notEquals_2 = (!Objects.equal(resultadoBusca, null));
          if (_notEquals_2) {
            resultadoBusca.setValue(Integer.valueOf(0));
          }
        }
      } else {
        function_designator _function = simples.getFunction();
        boolean _notEquals_3 = (!Objects.equal(_function, null));
        if (_notEquals_3) {
          this.checkAbstractionCall(bloco, simples.getFunction(), false);
        }
      }
    } else {
      structured_statement _structured = declaracao.getStructured();
      boolean _notEquals_4 = (!Objects.equal(_structured, null));
      if (_notEquals_4) {
        structured_statement estruturado = declaracao.getStructured();
        conditional_statement _conditional = estruturado.getConditional();
        boolean _notEquals_5 = (!Objects.equal(_conditional, null));
        if (_notEquals_5) {
          conditional_statement condicional = estruturado.getConditional();
          if_statement _ifStmt = condicional.getIfStmt();
          boolean _notEquals_6 = (!Objects.equal(_ifStmt, null));
          if (_notEquals_6) {
            if_statement declaracaoIf = condicional.getIfStmt();
            this.checkExpression(bloco, declaracaoIf.getExpression());
            boolean _equals = this.getType(bloco, declaracaoIf.getExpression()).getRealType().toLowerCase().equals(this.BOOLEAN);
            boolean _not_1 = (!_equals);
            if (_not_1) {
              this.insertError(declaracaoIf, this.BOOL_ONLY, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.IF_STATEMENT__EXPRESSION);
            } else {
              this.removeError(declaracaoIf.getExpression(), ErrorType.TYPE_CONVERSION_ERROR);
            }
            this.checkStatement(bloco, declaracaoIf.getIfStatement());
            statement _elseStatement = declaracaoIf.getElseStatement();
            boolean _notEquals_7 = (!Objects.equal(_elseStatement, null));
            if (_notEquals_7) {
              this.checkStatement(bloco, declaracaoIf.getElseStatement());
            }
          }
        }
      }
    }
  }
  
  public void checkStatements(final block bloco, final statement_sequence sequencia) {
    EList<statement> _statements = sequencia.getStatements();
    for (final statement declaracao : _statements) {
      this.checkStatement(bloco, declaracao);
    }
  }
  
  public void checkBlock(final block bloco) {
    this.checkStatements(bloco, bloco.getStatement().getSequence());
  }
  
  @Check
  public Object preencherTabela(final program prog) {
    Object _xblockexpression = null;
    {
      String nome = prog.getHeading().getName();
      Object _xifexpression = null;
      boolean _containsKey = PascalValidator.tabela_de_simbolos.containsKey(nome);
      boolean _not = (!_containsKey);
      if (_not) {
        Object _xblockexpression_1 = null;
        {
          HashMap<String, Object> _hashMap = new HashMap<String, Object>();
          PascalValidator.tabela_de_simbolos.put(nome, _hashMap);
          PascalValidator.tabela_de_simbolos.get(nome).put("variables", this.variaveis);
          PascalValidator.tabela_de_simbolos.get(nome).put("abstractions", this.procedimentos);
          PascalValidator.tabela_de_simbolos.get(nome).put("types", this.mapaDeTipos);
          _xblockexpression_1 = PascalValidator.tabela_de_simbolos.get(nome).put("calculatedTypes", this.mapaDeComparacoes);
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public void iniciarChecks(final block bloco) {
    this.checkTypeRedeclaration(bloco);
    this.checkAbstractionRedeclaration(bloco);
    this.checkConstantRedeclaration(bloco);
    this.checkVariableRedeclaration(bloco);
    this.checkBlock(bloco);
  }
  
  @Check
  public void showError(final EObject objeto) {
    boolean _containsKey = this.mapaDeErros.containsKey(objeto);
    if (_containsKey) {
      Set<org.xtext.ufcg.compiladores.validation.Error> _get = this.mapaDeErros.get(objeto);
      for (final org.xtext.ufcg.compiladores.validation.Error err : _get) {
        this.error(err.getMessage(), objeto, err.getFeature(), (-1));
      }
    }
  }
}
