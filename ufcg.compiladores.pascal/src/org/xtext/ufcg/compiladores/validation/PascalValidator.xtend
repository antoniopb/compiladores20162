/*
 * generated by Xtext 2.11.0.RC2
 */
package org.xtext.ufcg.compiladores.validation

import java.util.ArrayList
import java.util.HashMap
import java.util.Map
import java.util.Set
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.xtext.ufcg.compiladores.pascal.PascalPackage
import org.xtext.ufcg.compiladores.pascal.abstraction_declaration
import org.xtext.ufcg.compiladores.pascal.abstraction_heading
import org.xtext.ufcg.compiladores.pascal.any_number
import org.xtext.ufcg.compiladores.pascal.block
import org.xtext.ufcg.compiladores.pascal.constant
import org.xtext.ufcg.compiladores.pascal.constant_definition
import org.xtext.ufcg.compiladores.pascal.expression
import org.xtext.ufcg.compiladores.pascal.expression_list
import org.xtext.ufcg.compiladores.pascal.factor
import org.xtext.ufcg.compiladores.pascal.formal_parameter_section
import org.xtext.ufcg.compiladores.pascal.function_designator
import org.xtext.ufcg.compiladores.pascal.number
import org.xtext.ufcg.compiladores.pascal.parameter_type
import org.xtext.ufcg.compiladores.pascal.program
import org.xtext.ufcg.compiladores.pascal.simple_expression
import org.xtext.ufcg.compiladores.pascal.statement
import org.xtext.ufcg.compiladores.pascal.statement_sequence
import org.xtext.ufcg.compiladores.pascal.term
import org.xtext.ufcg.compiladores.pascal.type
import org.xtext.ufcg.compiladores.pascal.type_definition
import org.xtext.ufcg.compiladores.pascal.variable
import org.xtext.ufcg.compiladores.pascal.variable_section

class PascalValidator extends AbstractPascalValidator {
	
	// Tipos basicos
	
	private final String NIL = "nil";
	private final String RECORD = "record";
	private final String CHAR = "char";
	private final String BOOLEAN = "boolean";
	private final String INTEGER = "integer";
	private final String REAL = "real";
	private final String POINTER = "^";
	private final String ARRAY = "array of ";

	// Mensagens
	
	private final String UNDEFINED_TYPE_MESSAGE = "Tipo indefino";
	private final String CANNOT_CONVERT_MESSAGE = "Não é possivel converter ";
	private final String BOOL_ONLY = "Somente tipos booleanos são aceitos em condicionais.";
	private final String VAR_NOT_DECL = "Variavel não foi declarada.";
	private final String CONST_NOT_DECL = "Constante não pode ser redeclarada.";
	private final String CONST_ONLY = "Só são aceita constantes.";
	private final String NUM_ONLY = "Somente tipos numericos são aceitos.";
	private final String NAN = "A variavel não é um numerica.";
	private final String TO_BOOL = " para o tipo booleano.";
	private final String TO_NUM = " para um numerico.";
	private final String INVALID_OP = "Operador invalido para o tipo booleano.";
	private final String VAR_NOT_INIT = "Variavel não foi inicializada.";
	private final String RECEIVED = " foram recebidos ";
	private final String CANNOT_REDECLARE = " não pode ser redeclarada.";
	private final String FUNC_NOT_DECL = "Função não foi declarada.";
	private final String ID_FUNC_RETURN = "Identificador reservado para retorno de função.";
	private final String ID_IN_USE = "Identificador já está sendo usado por ";
	private final String CONST_CNOT_ASSIGN = "Constants cannot be assigned.";
	private final String ARG_WRONG_NUM = "Número incorreto de argumentos, esperava-se ";
	private final String ARGS = " argumentos.";
	private final String INCOMPATIBLE_TYPES = "Tipos de argumentos incompativeis, esperava-se ";
	private final String FUNC_ONLY = "Chamadas de Procedures não são permitidas em expressões.";
	private final String TO_MESSAGE = " para ";
	
	// inicializando a tabela de simbolos
	public static final Map<String, Map<String, Object>> tabela_de_simbolos = new HashMap<String, Map<String, Object>>();

	private final Map<block, Set<Variable>> variaveis = new AdaptativeHashMap<block, Variable>();
	// classe responsavel pela manipulacao de procedures
	private final Map<block, Set<Procedure>> procedures = new AdaptativeHashMap<block, Procedure>(APIProvider.procedures);
	// classe responsavel pela manipulacao de tipos
	// classe responsavel pela manipulacao dos erros
	private final Map<EObject, Set<Error>> listaDeErrors = new AdaptativeHashMap<EObject, Error>();
	// classe responsavel pela manipulacao das variaveis
	private final Map<block, Set<Type>> tipos = new AdaptativeHashMap<block, Type>(APIProvider.types);
	// classe responsavel pela manipulacao de comparacoes
	private final Map<EObject, Type> comparacoes = new HashMap<EObject, Type>();
	
	////////////////////////////////////////////////////////////////////// 
	//// Os checks estao aqui
	
	@Check
	/*
	 * Responsavel pelo preenchimento da tabela de simbolos pascal
	 */
	def preencherTabela(program prog) {
		var name = prog.heading.name;
		if (!tabela_de_simbolos.containsKey(name)) {
			tabela_de_simbolos.put(name, new HashMap<String, Object>());
			tabela_de_simbolos.get(name).put("variables", variaveis);
			tabela_de_simbolos.get(name).put("abstractions", procedures);
			tabela_de_simbolos.get(name).put("types", tipos);
			tabela_de_simbolos.get(name).put("calculatedTypes", comparacoes);
		}	
	}
	
	@Check
	/*
	 * Inicia os checks basicos do sistema
	 * Os outros checks estao sendo chamados dentro destes
	 */
	def iniciarChecks(block b) {
		checkTypeRedeclaration(b);
		checkAbstractionRedeclaration(b);
		checkConstantRedeclaration(b);
		checkVariableRedeclaration(b);
		checkBlock(b); 
	}
	////////////////////////////////////////////////////////////////////// 
	
	// Procura elementos
	def static <T extends Element> search(Set<T> elements, T key) {
		for (T elemento : elements) {
			if (elemento.equals(key))
				return elemento;
		} 
		return null;	
	}
	
	// Procura elementos, com verificacao de tipo
	def static searchWithTypeCoersion(Set<Procedure> elements, Procedure key) {
		var Procedure optimal = null; 
		for (Procedure procedimento : elements) {
			if (procedimento.equals(key))
				return procedimento;
			if (procedimento.equalsWithTypeCoersion(key))
				optimal = procedimento;
		}  
		return optimal;
	}
	 
	// Procura elemento dado nome
	def static Type searchByName(Set<Type> types, Type key) {
		for (Type tipo : types) {
			if (tipo.name.toLowerCase.equals(key.name.toLowerCase)) {
				return tipo;
			} 
		}	
		return null;
	}

	 
	def <T extends Element> clear(block b, ElementType type, Map<block, Set<T>> container) {
		var newSet = new AdaptativeTreeSet<T>();
		for (T element : container.get(b)) {
			if (element.type != type || element.isInherited) {
				newSet.add(element);
			}	 
		} 
		container.put(b, newSet);
	}
	
	def getParameters(block b, function_designator f) {
		var parameters = new ArrayList<Variable>();
		if (f.expressions != null) {
			var count = 0; 
			for (expression expr : f.expressions.expressions) {
				parameters.add(new Variable("arg_" + count, getType(b, expr), false, b, ElementType.PARAMETER));
				count++;
			} 
		}
		return parameters;
	}
	
	def getAbstraction(block b, function_designator f) {
		var name = f.name; 
		var parameters = getParameters(b, f);
		return new Procedure(name, parameters);	
	}
	
	def String getRealType(block b, String type) {
		var foundType = search(tipos.get(b), new Type(type));
		if (foundType != null) {
			return foundType.getRealType;
		}	
		return type;
	}
	
	
	// Retorna o tipo de elemento
	def Type getType(block b, String type) {
		if (type == null) return null;
		// Verifica se o inicio da string contem o caracter ^
		if (type.length > 1 && type.substring(0, 1).equals(POINTER)) {
			return new ComposedType(getType(b, type.substring(1)), ComposedTypeKind.POINTER);
		// Verifica se for array
		} else if (type.length > 9 && type.substring(0, 9).equals(ARRAY)) {
			return new ComposedType(getType(b, type.substring(9)), ComposedTypeKind.ARRAY);
		}
		// caso nao tenha sido um dos dois acima, vai para um nivel mais baixo
		return new Type(type, false, getRealType(b, type));	
	}
	
	def Type getComposedType(block b, String type, ComposedTypeKind kind) {
		return new ComposedType(getType(b, type), kind);
	}
	
	// Retorna o tipo da constante
	def Type getType(block bloco, constant constante) {
		var returnType = new Type(NIL);
		if (constante.name != null) {
			var varFound = search(variaveis.get(bloco), new Variable(constante.name));
			if (varFound != null) {
				returnType = varFound.varType;
			} 
		} else if (constante.string != null) {
			returnType = new ComposedType(new Type(CHAR), ComposedTypeKind.ARRAY);
		} else if (constante.boolLiteral != null) {
			returnType = new Type(BOOLEAN);
		} else if (constante.nil != null) {
			returnType = new Type(NIL);
		} else if (constante.number != null) {
			if (constante.number.number.integer != null) {
				returnType = new Type(INTEGER);
			} else if (constante.number.number.real != null) {
				returnType = new Type(REAL);
			} 
		}
		return returnType;
	}
	
	// Retorna o tipo composto, caso o elemento suporte
	def Type getType(block b, parameter_type type) {
		var returnType = new Type(NIL);
		if (type.array != null) {
			var array = type.array;
			if (array.packed != null) {
				returnType = new ComposedType(getType(b, array.packed.name), ComposedTypeKind.ARRAY);
			} else if (array.unpacked != null) {
				returnType = new ComposedType(getType(b, array.unpacked.type), ComposedTypeKind.ARRAY);
			}
		} else if (type.name != null) {
			if (search(tipos.get(b), new Type(type.name)) == null) {
				insertError(type, UNDEFINED_TYPE_MESSAGE, ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.PARAMETER_TYPE__NAME);
			} else {
				removeError(type, ErrorType.UNDEFINED_TYPE);
			}
			returnType = getType(b, type.name);
		}	
		return returnType;
	}
	
	def Type getType(block b, type type) {  
		var Type returnType = new Type(NIL);
		if (type.simple != null) {
			var simple = type.simple;
			if (simple.subrange != null || simple.enumerated != null) {
				returnType = new Type("enumerated", false, "...enumerated");
			} else if (simple.name != null) {
				if (search(tipos.get(b), new Type(simple.name)) == null) {
					insertError(type, UNDEFINED_TYPE_MESSAGE, ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.TYPE__SIMPLE);
				} else {
					removeError(type, ErrorType.UNDEFINED_TYPE);
				} 
				returnType = getType(b, simple.name);
			} 
		} else if (type.structured != null) {
			var structured = type.structured;
			var unpacked = structured.type;
			if (unpacked.array != null) {
				returnType = new ComposedType(getType(b, unpacked.array.type), ComposedTypeKind.ARRAY);
			} else if (unpacked.record != null) {
				returnType = new Type(RECORD);
			} else if (unpacked.set != null) {
				returnType = getType(b, unpacked.set.type);
			} else if (unpacked.file != null) {
				returnType = getType(b, unpacked.file.type);
			}
		} else if (type.pointer != null) {
			returnType = new ComposedType(getType(b, type.pointer.type), ComposedTypeKind.POINTER);
		} 
		return returnType;
	}
	
	def Type getType(block bloco, variable variavel) {
		var returnType = new Type(NIL);
		var variableFound = search(variaveis.get(bloco), new Variable(variavel.name)); 
		if (variableFound != null) {
			returnType = variableFound.varType;
		} 
		return returnType;
	} 
	
	
	
	def Type getType(block bloco, factor fator) {
		var returnType = new Type(NIL);
		if (fator.variable != null) {
			var variableFound = search(variaveis.get(bloco), new Variable(fator.variable.name));
			if (variableFound != null) {
				returnType = variableFound.varType;		
			}
		} else if (fator.number != null) {
			var number = fator.number.number;
			if (number.integer != null) {
				returnType = new Type(INTEGER);
			} else if (number.real != null) {
				returnType = new Type(REAL);
			}
		} else if (fator.string != null) {
			returnType = new ComposedType(new Type(CHAR), ComposedTypeKind.ARRAY);
		} else if (fator.set != null) {
			returnType = getType(bloco, fator.set.expressions, true); 
		} else if (fator.nil) {
			returnType = new Type(NIL);
		} else if (fator.boolean != null || fator.not != null) {
			returnType = new Type(BOOLEAN);
		} else if (fator.function != null) {
			returnType = getType(bloco, fator.function);
		} else if (fator.expression != null) {
			returnType = getType(bloco, fator.expression);
		}
		comparacoes.put(fator, returnType);
		return returnType;
	}
	
	// tipo de retorno da funcao
	def Type getType(block bloco, function_designator f) {
		var returnType = new Type(NIL);
		var function = getAbstraction(bloco, f);
		var abstractionFound = searchWithTypeCoersion(procedures.get(bloco), function);
		if (abstractionFound != null && abstractionFound.type == ElementType.FUNCTION) {
			var functionFound = abstractionFound as Function;
			returnType = functionFound.returnType;  
		}
		return returnType;
	}
	
	// widden
	def Type getType(block bloco, term termo) {
		var Type greatestType = null; 
		for (factor f : termo.factors) {
			var type = getType(bloco, f);
			greatestType = TypeInferer.greater(type, greatestType);
		}
		comparacoes.put(termo, greatestType);
		return greatestType;
	}
	
	//
	def Type getType(block bloco, expression expressao) {
		var returnType = new Type(NIL);
		if (expressao.operators != null && !expressao.operators.empty) {
			returnType = new Type(BOOLEAN);
		} else {
			var Type greatestType = null;
			for (simple_expression e : expressao.expressions) {
				var type = getType(bloco, e);
				greatestType = TypeInferer.greater(type, greatestType);
			}
			returnType = greatestType;
		}
		comparacoes.put(expressao, returnType);
		return returnType;
	}
	
	def Type getType(block bloco, simple_expression expressao) {
		var Type greatestType = null;
		for (EObject obj : expressao.terms) {
			if (obj instanceof term) {
				var termo = obj as term;
				var tipo = getType(bloco, termo);
				greatestType = TypeInferer.greater(tipo, greatestType);
			} else {
				var numero = obj as any_number;
				if (numero.integer != null) {
					greatestType = TypeInferer.greater(new Type(INTEGER), greatestType);
				} else {
					greatestType = TypeInferer.greater(new Type(REAL), greatestType);
				}
			}
		}
		comparacoes.put(expressao, greatestType);
		return greatestType;
	}
	
	def Type getType(block bloco, expression_list expressoes, boolean coeso) {
		var Type greatestType = null;
		var hasErrors = true;
		for (expression expressao : expressoes.expressions) {
			var type = getType(bloco, expressao);
			if (coeso) {
				if (greatestType != null && TypeInferer.getTypeWeight(greatestType) < 0 && TypeInferer.getTypeWeight(type) >= 0 || 
					TypeInferer.getTypeWeight(type) < 0 && TypeInferer.getTypeWeight(greatestType) >= 0) {
					insertError(expressoes, CANNOT_CONVERT_MESSAGE + type +  TO_MESSAGE + greatestType + ".", ErrorType.TYPE_COHESION, PascalPackage.Literals.EXPRESSION_LIST__EXPRESSIONS);
					hasErrors = true;
				} 
			}
			greatestType = TypeInferer.greater(type, greatestType);
		}
		if (!hasErrors) {
			removeError(expressoes, ErrorType.TYPE_COHESION);
		}
		comparacoes.put(expressoes, greatestType);
		return greatestType;
	}
	
	def static boolean isNumeric(Object obj) {
		try {
			 Double.parseDouble(obj.toString); 
		} catch(Exception e) {
			return false;
		}
		return true;
	}
	
	def static Object getValue(number numero) {
		if (numero.number.integer != null) {
			return Integer.valueOf(numero.number.integer);
		} else if (numero.number.real != null) {
			return Double.valueOf(numero.number.real);
		}
		return null;
	}
	
	def static Object getValue(constant constante, Set<Variable> variables) {
		var Object value = null;
		if (constante.name != null) {
			var variable = search(variables, new Variable(constante.name));
			value = variable.getValue;
		} else if (constante.number != null) {
			value = getValue(constante.number);
		} else if (constante.string != null) {
			value = constante.string;
		} else if (constante.boolLiteral != null) {
			value = Boolean.valueOf(constante.boolLiteral);
		} else if (constante.nil != null) {
			value = null;
		}
		if (constante.opterator != null) {
			if (isNumeric(value) && constante.opterator.equals("-")) {
				try {
					return - Integer.parseInt(value.toString);
				} catch(Exception e) {
					return - Double.parseDouble(value.toString);
				}
			}
		}
		return value;
	}
	
	def <T extends Element> addElement(block bloco, T elemento, Map<block, Set<T>> container, EObject errorSection, EStructuralFeature errorFeature) {			
		var T elementFound;
		if (container == tipos) {
			var type = elemento as Type;
			elementFound = searchByName(tipos.get(bloco), type) as T;  
		} else {
			elementFound = search(container.get(bloco), elemento);
		}
		if (elementFound != null && !elementFound.isInherited) {
			if (elemento.type == elementFound.type) { 
				insertError(errorSection, elemento.type + CANNOT_REDECLARE, ErrorType.REDECLARATION, errorFeature); 
			} else { 
				if (elementFound.type == ElementType.FUNCTION_RETURN) {
					insertError(errorSection, ID_FUNC_RETURN, ErrorType.REDECLARATION, errorFeature);
				} else {
					insertError(errorSection, ID_IN_USE + elementFound.type.toString().toLowerCase() + ".", ErrorType.REDECLARATION, errorFeature);
				} 
			}
		} else { 
			removeError(errorSection, ErrorType.REDECLARATION);
			container.get(bloco).add(elemento);
			var inheritedElement = elemento.clone() as T;
			inheritedElement.inherited = true; 
			inheritElement(bloco, inheritedElement, container);
		}
	}
	
	def <T extends Element> inheritElement(block bloco, T elemento, Map<block, Set<T>> container) {
		if (bloco.declaration.abstraction != null) {
			if (bloco.declaration.abstraction.procedures != null) {
				for (abstraction_declaration procedure : bloco.declaration.abstraction.procedures) {
					addElementToAbstraction(procedure, elemento, container);
				}
			}
			if (bloco.declaration.abstraction.functions != null) {
				for (abstraction_declaration function : bloco.declaration.abstraction.functions) {
					addElementToAbstraction(function, elemento, container);
				}
			}
		}
	} 
	
	def <T extends Element> addElementToAbstraction(abstraction_declaration decl, T elemento, Map<block, Set<T>> container) {
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		var subblock = decl.block;
		container.get(subblock).add(elemento);
	}
	 
	def getParameters(block b, abstraction_heading heading, block abstractionBlock) {
		var parameters = new ArrayList<Variable>();
		if (heading.parameters != null) {
			var list = heading.parameters;
			if (list.parameters != null) {
				for (formal_parameter_section section : list.parameters) {
					if (section.variable != null) {
						var variable = section.variable;
						for (String varName : variable.identifiers.ids) { 
							var parameter = new Variable(varName, getType(b, section.variable.type), false, abstractionBlock, ElementType.PARAMETER);
							addElement(b, parameter, variaveis, variable, PascalPackage.Literals.VARIABLE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					} else if (section.value != null) {
						var value = section.value;
						for (String valName : value.identifiers.ids) {
							var parameter = new Variable(valName, getType(b, value.type), false, abstractionBlock, ElementType.PARAMETER);
							addElement(b, parameter, variaveis, value, PascalPackage.Literals.VALUE_PARAMETER_SECTION__IDENTIFIERS);
							parameters.add(parameter);
						}
					}
				}
			}
		}
		return parameters;
	}
	 
	def addAbstraction(block b, abstraction_declaration decl, abstraction_heading heading) {
		var name = heading.name;
		if (decl.block == null) {
			decl.block = PascalPackage.eINSTANCE.pascalFactory.createblock;
		}
		clear(decl.block, ElementType.PARAMETER, variaveis); 
		var parameters = getParameters(decl.block, heading, decl.block);
		var forward = decl.forward;
		var returnType = heading.resultType;
		if (returnType != null) {  
			if (search(tipos.get(b), new Type(returnType)) == null) {
				insertError(heading, UNDEFINED_TYPE_MESSAGE, ErrorType.UNDEFINED_TYPE, PascalPackage.Literals.ABSTRACTION_HEADING__RESULT_TYPE);
			} else {
				removeError(heading, ErrorType.UNDEFINED_TYPE);
			} 
			var function = new Function(name, forward, b, decl, parameters, forward, getType(b, returnType));
			addElement(b, function, procedures, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME); 
			var returnVariable = new Variable(name, getType(b, returnType), false, decl.block, ElementType.FUNCTION_RETURN);
			returnVariable.setOwningFunction(function);
			variaveis.get(decl.block).add(returnVariable);
		} else {
			addElement(b, new Procedure(name, forward, b, decl, parameters, forward), procedures, heading, PascalPackage.Literals.ABSTRACTION_HEADING__NAME);
		}
	} 
	
	def checkAbstractionRedeclaration(block b) {
		if (b.declaration.abstraction != null) {
			clear(b, ElementType.FUNCTION, procedures); 
			clear(b, ElementType.PROCEDURE, procedures); 
			var abstraction = b.declaration.abstraction;
			if (abstraction.functions != null) {
				for (abstraction_declaration function : abstraction.functions) {
					addAbstraction(b, function, function.heading);
				}
			}
			if (abstraction.procedures != null) {
				for (abstraction_declaration procedure : abstraction.procedures) {
					addAbstraction(b, procedure, procedure.heading);
				}
			}
		}	
	}
	
	def checkTypeRedeclaration(block b) {
		clear(b, ElementType.TYPE, tipos);
		if (b.declaration.type_def != null) {
			for (type_definition t : b.declaration.type_def.types) {
				addElement(b, new Type(t.name, false, getType(b, t.type).getRealType), tipos, t, PascalPackage.Literals.TYPE_DEFINITION__NAME);
			}
		}	 
	}
	 
	def checkConstantRedeclaration(block b) {
		clear(b, ElementType.CONSTANT, variaveis);
		if (b.declaration.constant_def != null) {
			for (constant_definition const : b.declaration.constant_def.consts) {
				addElement(b, new Variable(const.name, getType(b, const.const), false, b, ElementType.CONSTANT, getValue(const.const, variaveis.get(b))), variaveis, const, PascalPackage.Literals.CONSTANT_DEFINITION__NAME);
			}
		}
	} 
	
	def checkVariableRedeclaration(block b) {		
		clear(b, ElementType.VARIABLE, variaveis);
		if (b.declaration.variable_decl != null) {
			for (variable_section section : b.declaration.variable_decl.sections) {
				for (String name : section.identifiers.names) { 
					var type = getType(b, section.type);
					addElement(b, new Variable(name, type, false, b, ElementType.VARIABLE), variaveis, section, PascalPackage.Literals.VARIABLE_SECTION__IDENTIFIERS);
				}
			}
		}
	}
	
	def boolean checkVariable(block b, variable v, boolean isAssignment) { 
		var isValid = true;
		if (v == null) return true;
		var searchVariable = search(variaveis.get(b), new Variable(v.name));
		if (searchVariable == null) {
			isValid = false;
			insertError(v, VAR_NOT_DECL, ErrorType.NOT_DECLARATION, PascalPackage.Literals.VARIABLE__NAME);
		} else {
			removeError(v, ErrorType.NOT_DECLARATION);
			if (isAssignment) {
				if (searchVariable.type == ElementType.CONSTANT) {
					isValid = false;
					insertError(v, CONST_CNOT_ASSIGN, ErrorType.CONSTANT_ASSIGNMENT, PascalPackage.Literals.VARIABLE__NAME);
				} else {
					removeError(v, ErrorType.CONSTANT_ASSIGNMENT);
				}
			}
		}
		return isValid; 
	}
	
	def checkAbstraction(block b, Procedure proc, boolean functionOnly, EObject object, EStructuralFeature feature) {
		var abstractionFound = searchWithTypeCoersion(procedures.get(b), proc);
		if (abstractionFound == null) {  
			for (Procedure p : procedures.get(b)) {
				if (p.name.toLowerCase.equals(proc.name.toLowerCase)) {
					if (p.parameters.size != proc.parameters.size) {
						insertError(object, ARG_WRONG_NUM + p.parameters.size + RECEIVED + proc.parameters.size + ARGS, ErrorType.NOT_DECLARATION, feature);
					} else {
						var it1 = p.parameters.iterator;
						var it2 = proc.parameters.iterator;
						while (it1.hasNext && it2.hasNext) {
							var type1 = it1.next;
							var type2 = it2.next; 
							if (!TypeInferer.areTypesCompatibles(type1.varType, type2.varType)) {
								insertError(object, INCOMPATIBLE_TYPES + p.parameters + RECEIVED + proc.parameters + ".", ErrorType.NOT_DECLARATION, feature);
								return;
							}	
						}
					}
					return;
				}
			}
			insertError(object, FUNC_NOT_DECL, ErrorType.NOT_DECLARATION, feature); 
		} else {
			removeError(object, ErrorType.NOT_DECLARATION);
			if (abstractionFound.type == ElementType.PROCEDURE && functionOnly) {
				insertError(object, FUNC_ONLY, ErrorType.FUNCTION_ONLY, feature);
			} else {
				removeError(object, ErrorType.FUNCTION_ONLY);
			}
		}
	} 
	
	
	def void checkAbstractionCall(block b, function_designator function, boolean functionOnly) {
		if (function.expressions != null) {
			for (expression e : function.expressions.expressions) {
				checkExpression(b, e);
			}
		}
		checkAbstraction(b, getAbstraction(b, function), functionOnly, function, PascalPackage.Literals.FUNCTION_DESIGNATOR__NAME); 
	}  
	
	def void checkFactor(block b, factor f) {
		if (f.variable != null) {
			checkVariable(b, f.variable, false);
			if (variaveis.containsKey(b)) {
				var v = search(variaveis.get(b), new Variable(f.variable.name));
				if (v != null && v.value == null) {
					insertError(f, VAR_NOT_INIT, ErrorType.NOT_INITIALIZED, PascalPackage.Literals.FACTOR__VARIABLE);
				} else {
					removeError(f, ErrorType.NOT_INITIALIZED);
				}		
			}
		} else if (f.function != null) {	
			checkAbstractionCall(b, f.function, true);
		} else if (f.not != null) {
			if (!getType(b, f.not).getRealType.toLowerCase.equals(BOOLEAN)) {
				insertError(f, CANNOT_CONVERT_MESSAGE + getType(b, f.not) + TO_BOOL, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.FACTOR__NOT);
			} else {
				removeError(f, ErrorType.TYPE_CONVERSION_ERROR);
			}
			checkFactor(b, f.not); 
		} else if (f.expression != null) {
			checkExpression(b, f.expression);
		}
	}
	
	// Verificacao de operadores
	def void checkTerm(block b, term t) {
		var isBoolean = false;
		var isNumeric = false;
		if (t.operators != null) {
			for (String op : t.operators) {
				if (op.toLowerCase.equals("and")) {
					isBoolean = true;
				} else if (!isBoolean) {
					isNumeric = true;
				} else {
					insertError(t, INVALID_OP, ErrorType.INVALID_OPERATOR, PascalPackage.Literals.TERM__OPERATORS);	
					return;
				}
			}
		}
		removeError(t, ErrorType.INVALID_OPERATOR);
		for (factor f : t.factors) {
			if (isBoolean) {
				if (!getType(b, f).getRealType.toLowerCase.equals(BOOLEAN)) {
					insertError(t, CANNOT_CONVERT_MESSAGE + getType(b, f) + TO_BOOL, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			} else if (isNumeric) {
				if (TypeInferer.getTypeWeight(getType(b, f)) == -1) {
					insertError(t, CANNOT_CONVERT_MESSAGE + getType(b, f) + TO_NUM, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.TERM__FACTORS);		
				} else {
					removeError(t, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
			checkFactor(b, f);
		}
	}
	
	// Verificacao de expressoes
	def void checkExpression(block b, expression expr) {
		for (simple_expression s : expr.expressions) {
			var isBoolean = false;
			var isNumeric = false;
			if (s.prefixOperator != null) {
				isNumeric = true;
			}
			if (s.operators != null) {
				for (String op : s.operators) {
					if (op.toLowerCase.equals("or")) {
						isBoolean = true;
					} else if (!isBoolean) {
						isNumeric = true;
					} else {
						insertError(s, INVALID_OP, ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
						return;
					} 
				}
			}
			if (isNumeric && isBoolean) {
				insertError(s, NUM_ONLY, ErrorType.INVALID_OPERATOR, PascalPackage.Literals.SIMPLE_EXPRESSION__OPERATORS);	
			} else {
				removeError(s, ErrorType.INVALID_OPERATOR);
				for (EObject obj : s.terms) {
					if (obj instanceof term) {
						var t = obj as term;
						if (isBoolean) {
							if (!getType(b, t).getRealType.toLowerCase.equals(BOOLEAN)) {
								insertError(s, CANNOT_CONVERT_MESSAGE + getType(b, t) + TO_BOOL, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);		
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						} else if (isNumeric) {
							if (TypeInferer.getTypeWeight(getType(b, t)) == -1) {
								insertError(s, CANNOT_CONVERT_MESSAGE + getType(b, t) + TO_NUM, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
							} else {
								removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
							}
						}
						checkTerm(b, t);
					} else if (!isNumeric) {
						insertError(s, NUM_ONLY, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.SIMPLE_EXPRESSION__TERMS);
					} else {
						removeError(s, ErrorType.TYPE_CONVERSION_ERROR);
					}
				}
			}
		}
	}
	
	// Verificacao da declaracao de constantes
	def checkConstant(block b, constant const) {
		if (const.name != null) {
			var searchVariable = search(variaveis.get(b), new Variable(const.name));
			if (searchVariable == null) {
				insertError(const, CONST_NOT_DECL, ErrorType.NOT_DECLARATION, PascalPackage.Literals.CONSTANT__NAME);
			} else {
				removeError(const, ErrorType.NOT_DECLARATION);
				if (searchVariable.type != ElementType.CONSTANT) {
					insertError(const, CONST_ONLY , ErrorType.CONSTANT_ONLY, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.CONSTANT_ONLY);
				}
				if (const.opterator != null && TypeInferer.getTypeWeight(searchVariable.varType) < 0) {
					insertError(const, NAN , ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.CONSTANT__NAME);
				} else {
					removeError(const, ErrorType.TYPE_CONVERSION_ERROR);
				}
			}
		}
	}
	
	// Verificacao do escopo do if then else
	def void checkStatement(block b, statement stmt) {
		if (stmt.simple != null) {
			var simple = stmt.simple;
			if (simple.assignment != null) {
				if (checkVariable(b, simple.assignment.variable, true)) {
					var variableType = getType(b, simple.assignment.variable);
					var expressionType = getType(b, simple.assignment.expression);
					if (!TypeInferer.areTypesCompatibles(variableType, expressionType)) { 
						 insertError(simple.assignment, CANNOT_CONVERT_MESSAGE + expressionType + TO_MESSAGE + variableType + ".", ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.ASSIGNMENT_STATEMENT__EXPRESSION);
					} else {
						removeError(simple.assignment, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkExpression(b, simple.assignment.expression);
					var v = search(variaveis.get(b), new Variable(simple.assignment.variable.name));
					if (v != null) {
						v.setValue(0); 
					}
				}
			} else if (simple.function != null) {
				checkAbstractionCall(b, simple.function, false); 
			}
		} else if (stmt.structured != null) {
			var structured = stmt.structured;
			 if (structured.conditional != null) {
				var conditional = structured.conditional;
				if (conditional.ifStmt != null) {
					var ifStmt = conditional.ifStmt;
					checkExpression(b, ifStmt.expression);
					if (!getType(b, ifStmt.expression).getRealType.toLowerCase.equals(BOOLEAN)) {
						insertError(ifStmt, BOOL_ONLY, ErrorType.TYPE_CONVERSION_ERROR, PascalPackage.Literals.IF_STATEMENT__EXPRESSION);
					} else {
						removeError(ifStmt.expression, ErrorType.TYPE_CONVERSION_ERROR);
					}
					checkStatement(b, ifStmt.ifStatement);
					if (ifStmt.elseStatement != null) {
						checkStatement(b, ifStmt.elseStatement);
					}
				} 
			}
		}
	}
	
		
	def checkStatements(block b, statement_sequence sequence) {
		for (statement stmt : sequence.statements) {
			checkStatement(b, stmt);
		}
	} 
	
	def checkBlock(block b) {
		checkStatements(b, b.statement.sequence);
	}
	
	////////////////////////////////////////////////////////////////////// 
	// Funcoes para manipulacao de erros gerados devido a erros de tipo // 
	def insertError(EObject object, String message, ErrorType type, EStructuralFeature feature) {
		listaDeErrors.get(object).add(new Error(message, type, feature));
	}
	
	def removeError(EObject object, ErrorType type) {
		listaDeErrors.get(object).remove(new Error(type));
		showError(object);
	}
	
		@Check
	def showError(EObject obj) {
		if (listaDeErrors.containsKey(obj)) {
			for (Error err : listaDeErrors.get(obj)) {
				error(err.message, obj, err.feature, -1);
			} 
			
		} 
	}
	//////////////////////////////////////////////////////////////////////  


}	